// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: helios/permissions/v1beta1/query.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryParamsRequest is the request type for the Query/Params RPC method.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         { *m = QueryParamsRequest{} }
func (m *QueryParamsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryParamsRequest) ProtoMessage()    {}
func (*QueryParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{0}
}
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}
func (m *QueryParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is the response type for the Query/Params RPC method.
type QueryParamsResponse struct {
	// params defines the parameters of the module.
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         { *m = QueryParamsResponse{} }
func (m *QueryParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryParamsResponse) ProtoMessage()    {}
func (*QueryParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{1}
}
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}
func (m *QueryParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// QueryAllNamespacesRequest is the request type for the Query/AllNamespaces RPC
// method.
type QueryAllNamespacesRequest struct {
}

func (m *QueryAllNamespacesRequest) Reset()         { *m = QueryAllNamespacesRequest{} }
func (m *QueryAllNamespacesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAllNamespacesRequest) ProtoMessage()    {}
func (*QueryAllNamespacesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{2}
}
func (m *QueryAllNamespacesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAllNamespacesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAllNamespacesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAllNamespacesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAllNamespacesRequest.Merge(m, src)
}
func (m *QueryAllNamespacesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAllNamespacesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAllNamespacesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAllNamespacesRequest proto.InternalMessageInfo

// QueryAllNamespacesResponse is the response type for the Query/AllNamespaces
// RPC method.
type QueryAllNamespacesResponse struct {
	Namespaces []*Namespace `protobuf:"bytes,1,rep,name=namespaces,proto3" json:"namespaces,omitempty"`
}

func (m *QueryAllNamespacesResponse) Reset()         { *m = QueryAllNamespacesResponse{} }
func (m *QueryAllNamespacesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAllNamespacesResponse) ProtoMessage()    {}
func (*QueryAllNamespacesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{3}
}
func (m *QueryAllNamespacesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAllNamespacesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAllNamespacesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAllNamespacesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAllNamespacesResponse.Merge(m, src)
}
func (m *QueryAllNamespacesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAllNamespacesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAllNamespacesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAllNamespacesResponse proto.InternalMessageInfo

func (m *QueryAllNamespacesResponse) GetNamespaces() []*Namespace {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

// QueryNamespaceByDenomRequest is the request type for the
// Query/NamespaceByDenom RPC method.
type QueryNamespaceByDenomRequest struct {
	Denom        string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	IncludeRoles bool   `protobuf:"varint,2,opt,name=include_roles,json=includeRoles,proto3" json:"include_roles,omitempty"`
}

func (m *QueryNamespaceByDenomRequest) Reset()         { *m = QueryNamespaceByDenomRequest{} }
func (m *QueryNamespaceByDenomRequest) String() string { return proto.CompactTextString(m) }
func (*QueryNamespaceByDenomRequest) ProtoMessage()    {}
func (*QueryNamespaceByDenomRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{4}
}
func (m *QueryNamespaceByDenomRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryNamespaceByDenomRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryNamespaceByDenomRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryNamespaceByDenomRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryNamespaceByDenomRequest.Merge(m, src)
}
func (m *QueryNamespaceByDenomRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryNamespaceByDenomRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryNamespaceByDenomRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryNamespaceByDenomRequest proto.InternalMessageInfo

func (m *QueryNamespaceByDenomRequest) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *QueryNamespaceByDenomRequest) GetIncludeRoles() bool {
	if m != nil {
		return m.IncludeRoles
	}
	return false
}

// QueryNamespaceByDenomResponse is the response type for the
// Query/NamespaceByDenom RPC method.
type QueryNamespaceByDenomResponse struct {
	Namespace *Namespace `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *QueryNamespaceByDenomResponse) Reset()         { *m = QueryNamespaceByDenomResponse{} }
func (m *QueryNamespaceByDenomResponse) String() string { return proto.CompactTextString(m) }
func (*QueryNamespaceByDenomResponse) ProtoMessage()    {}
func (*QueryNamespaceByDenomResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{5}
}
func (m *QueryNamespaceByDenomResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryNamespaceByDenomResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryNamespaceByDenomResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryNamespaceByDenomResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryNamespaceByDenomResponse.Merge(m, src)
}
func (m *QueryNamespaceByDenomResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryNamespaceByDenomResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryNamespaceByDenomResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryNamespaceByDenomResponse proto.InternalMessageInfo

func (m *QueryNamespaceByDenomResponse) GetNamespace() *Namespace {
	if m != nil {
		return m.Namespace
	}
	return nil
}

// QueryAddressesByRoleRequest is the request type for the Query/AddressesByRole
// RPC method.
type QueryAddressesByRoleRequest struct {
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Role  string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *QueryAddressesByRoleRequest) Reset()         { *m = QueryAddressesByRoleRequest{} }
func (m *QueryAddressesByRoleRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAddressesByRoleRequest) ProtoMessage()    {}
func (*QueryAddressesByRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{6}
}
func (m *QueryAddressesByRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAddressesByRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAddressesByRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAddressesByRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAddressesByRoleRequest.Merge(m, src)
}
func (m *QueryAddressesByRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAddressesByRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAddressesByRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAddressesByRoleRequest proto.InternalMessageInfo

func (m *QueryAddressesByRoleRequest) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *QueryAddressesByRoleRequest) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// QueryAddressesByRoleResponse is the response type for the
// Query/AddressesByRole RPC method.
type QueryAddressesByRoleResponse struct {
	Addresses []string `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
}

func (m *QueryAddressesByRoleResponse) Reset()         { *m = QueryAddressesByRoleResponse{} }
func (m *QueryAddressesByRoleResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAddressesByRoleResponse) ProtoMessage()    {}
func (*QueryAddressesByRoleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{7}
}
func (m *QueryAddressesByRoleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAddressesByRoleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAddressesByRoleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAddressesByRoleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAddressesByRoleResponse.Merge(m, src)
}
func (m *QueryAddressesByRoleResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAddressesByRoleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAddressesByRoleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAddressesByRoleResponse proto.InternalMessageInfo

func (m *QueryAddressesByRoleResponse) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

type QueryAddressRolesRequest struct {
	Denom   string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryAddressRolesRequest) Reset()         { *m = QueryAddressRolesRequest{} }
func (m *QueryAddressRolesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAddressRolesRequest) ProtoMessage()    {}
func (*QueryAddressRolesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{8}
}
func (m *QueryAddressRolesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAddressRolesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAddressRolesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAddressRolesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAddressRolesRequest.Merge(m, src)
}
func (m *QueryAddressRolesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAddressRolesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAddressRolesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAddressRolesRequest proto.InternalMessageInfo

func (m *QueryAddressRolesRequest) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *QueryAddressRolesRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type QueryAddressRolesResponse struct {
	Roles []string `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *QueryAddressRolesResponse) Reset()         { *m = QueryAddressRolesResponse{} }
func (m *QueryAddressRolesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAddressRolesResponse) ProtoMessage()    {}
func (*QueryAddressRolesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{9}
}
func (m *QueryAddressRolesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAddressRolesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAddressRolesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAddressRolesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAddressRolesResponse.Merge(m, src)
}
func (m *QueryAddressRolesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAddressRolesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAddressRolesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAddressRolesResponse proto.InternalMessageInfo

func (m *QueryAddressRolesResponse) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

type QueryVouchersForAddressRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryVouchersForAddressRequest) Reset()         { *m = QueryVouchersForAddressRequest{} }
func (m *QueryVouchersForAddressRequest) String() string { return proto.CompactTextString(m) }
func (*QueryVouchersForAddressRequest) ProtoMessage()    {}
func (*QueryVouchersForAddressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{10}
}
func (m *QueryVouchersForAddressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVouchersForAddressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVouchersForAddressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVouchersForAddressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVouchersForAddressRequest.Merge(m, src)
}
func (m *QueryVouchersForAddressRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryVouchersForAddressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVouchersForAddressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVouchersForAddressRequest proto.InternalMessageInfo

func (m *QueryVouchersForAddressRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type QueryVouchersForAddressResponse struct {
	Vouchers github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=vouchers,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"vouchers,omitempty"`
}

func (m *QueryVouchersForAddressResponse) Reset()         { *m = QueryVouchersForAddressResponse{} }
func (m *QueryVouchersForAddressResponse) String() string { return proto.CompactTextString(m) }
func (*QueryVouchersForAddressResponse) ProtoMessage()    {}
func (*QueryVouchersForAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7be6ab5c40e5f4ab, []int{11}
}
func (m *QueryVouchersForAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVouchersForAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVouchersForAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVouchersForAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVouchersForAddressResponse.Merge(m, src)
}
func (m *QueryVouchersForAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryVouchersForAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVouchersForAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVouchersForAddressResponse proto.InternalMessageInfo

func (m *QueryVouchersForAddressResponse) GetVouchers() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Vouchers
	}
	return nil
}

func init() {
	proto.RegisterType((*QueryParamsRequest)(nil), "helios.permissions.v1beta1.QueryParamsRequest")
	proto.RegisterType((*QueryParamsResponse)(nil), "helios.permissions.v1beta1.QueryParamsResponse")
	proto.RegisterType((*QueryAllNamespacesRequest)(nil), "helios.permissions.v1beta1.QueryAllNamespacesRequest")
	proto.RegisterType((*QueryAllNamespacesResponse)(nil), "helios.permissions.v1beta1.QueryAllNamespacesResponse")
	proto.RegisterType((*QueryNamespaceByDenomRequest)(nil), "helios.permissions.v1beta1.QueryNamespaceByDenomRequest")
	proto.RegisterType((*QueryNamespaceByDenomResponse)(nil), "helios.permissions.v1beta1.QueryNamespaceByDenomResponse")
	proto.RegisterType((*QueryAddressesByRoleRequest)(nil), "helios.permissions.v1beta1.QueryAddressesByRoleRequest")
	proto.RegisterType((*QueryAddressesByRoleResponse)(nil), "helios.permissions.v1beta1.QueryAddressesByRoleResponse")
	proto.RegisterType((*QueryAddressRolesRequest)(nil), "helios.permissions.v1beta1.QueryAddressRolesRequest")
	proto.RegisterType((*QueryAddressRolesResponse)(nil), "helios.permissions.v1beta1.QueryAddressRolesResponse")
	proto.RegisterType((*QueryVouchersForAddressRequest)(nil), "helios.permissions.v1beta1.QueryVouchersForAddressRequest")
	proto.RegisterType((*QueryVouchersForAddressResponse)(nil), "helios.permissions.v1beta1.QueryVouchersForAddressResponse")
}

func init() {
	proto.RegisterFile("helios/permissions/v1beta1/query.proto", fileDescriptor_7be6ab5c40e5f4ab)
}

var fileDescriptor_7be6ab5c40e5f4ab = []byte{
	// 803 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x96, 0xcf, 0x4f, 0xdb, 0x4a,
	0x10, 0xc7, 0xb3, 0x3c, 0xe0, 0x91, 0x01, 0xf4, 0x9e, 0xf6, 0xe5, 0x10, 0x0c, 0xcf, 0x41, 0x7e,
	0xbf, 0x22, 0x04, 0x36, 0xe4, 0x15, 0x4a, 0x69, 0x0f, 0x6d, 0x68, 0xa9, 0x54, 0x55, 0x55, 0xeb,
	0x43, 0xab, 0xf6, 0x12, 0x39, 0xce, 0x36, 0xb1, 0x6a, 0x7b, 0x8d, 0xd7, 0x41, 0xca, 0xa1, 0x97,
	0xfe, 0x05, 0x95, 0xaa, 0xde, 0x7b, 0xee, 0x91, 0x6b, 0x0f, 0x3d, 0x96, 0x23, 0x12, 0x97, 0x9e,
	0x68, 0x05, 0x3d, 0xf5, 0xaf, 0xa8, 0xbc, 0xbb, 0x36, 0x09, 0x21, 0x0e, 0xd0, 0x13, 0xde, 0x9d,
	0xf9, 0xce, 0x7c, 0x66, 0xd8, 0x19, 0x05, 0xfe, 0x6d, 0x11, 0xd7, 0xa1, 0xcc, 0x08, 0x48, 0xe8,
	0x39, 0x8c, 0x39, 0xd4, 0x67, 0xc6, 0xce, 0x4a, 0x9d, 0x44, 0xd6, 0x8a, 0xb1, 0xdd, 0x26, 0x61,
	0x47, 0x0f, 0x42, 0x1a, 0x51, 0xac, 0x08, 0x3f, 0xbd, 0xcb, 0x4f, 0x97, 0x7e, 0x4a, 0xa1, 0x49,
	0x9b, 0x94, 0xbb, 0x19, 0xf1, 0x97, 0x50, 0x28, 0x73, 0x4d, 0x4a, 0x9b, 0x2e, 0x31, 0xac, 0xc0,
	0x31, 0x2c, 0xdf, 0xa7, 0x91, 0x15, 0x71, 0x95, 0xb0, 0xaa, 0x36, 0x65, 0x1e, 0x65, 0x46, 0xdd,
	0x62, 0x24, 0x4d, 0x68, 0x53, 0xc7, 0x97, 0xf6, 0x85, 0x6e, 0x3b, 0x07, 0x49, 0xbd, 0x02, 0xab,
	0xe9, 0xf8, 0x3c, 0x98, 0xf4, 0xfd, 0x2f, 0xa3, 0x86, 0xc0, 0x0a, 0x2d, 0x2f, 0x49, 0x5a, 0xce,
	0x70, 0x6c, 0x12, 0x9f, 0x30, 0x27, 0xf1, 0x5c, 0xcc, 0x0a, 0xd9, 0xd5, 0x02, 0xee, 0xad, 0x15,
	0x00, 0x3f, 0x8a, 0x11, 0x1f, 0xf2, 0x64, 0x26, 0xd9, 0x6e, 0x13, 0x16, 0x69, 0x4f, 0xe0, 0x8f,
	0x9e, 0x5b, 0x16, 0x50, 0x9f, 0x11, 0x7c, 0x13, 0xc6, 0x05, 0x54, 0x11, 0xcd, 0xa3, 0xf2, 0x64,
	0x45, 0xd3, 0x07, 0xb7, 0x56, 0x17, 0xda, 0xea, 0xe8, 0xde, 0x61, 0x29, 0x67, 0x4a, 0x9d, 0x36,
	0x0b, 0x33, 0x3c, 0xf0, 0x2d, 0xd7, 0x7d, 0x60, 0x79, 0x84, 0x05, 0x96, 0x4d, 0xd2, 0xac, 0x36,
	0x28, 0x67, 0x19, 0x65, 0xf2, 0x3b, 0x00, 0x7e, 0x7a, 0x5b, 0x44, 0xf3, 0xbf, 0x94, 0x27, 0x2b,
	0xff, 0x64, 0x01, 0xa4, 0x31, 0xcc, 0x2e, 0xa1, 0xf6, 0x14, 0xe6, 0x78, 0x92, 0xd4, 0x5a, 0xed,
	0xdc, 0x26, 0x3e, 0xf5, 0x24, 0x04, 0x2e, 0xc0, 0x58, 0x23, 0x3e, 0xf3, 0x12, 0xf3, 0xa6, 0x38,
	0xe0, 0xbf, 0x60, 0xda, 0xf1, 0x6d, 0xb7, 0xdd, 0x20, 0xb5, 0x90, 0xba, 0x84, 0x15, 0x47, 0xe6,
	0x51, 0x79, 0xc2, 0x9c, 0x92, 0x97, 0x66, 0x7c, 0xa7, 0x35, 0xe0, 0xcf, 0x01, 0xa1, 0x65, 0x09,
	0x9b, 0x90, 0x4f, 0x49, 0x64, 0x0b, 0xcf, 0x59, 0xc1, 0x89, 0x4e, 0xbb, 0x0b, 0xb3, 0xa2, 0x4b,
	0x8d, 0x46, 0x48, 0x18, 0x23, 0xac, 0xda, 0x89, 0xd3, 0x67, 0xf3, 0x63, 0x18, 0x8d, 0xb9, 0x39,
	0x76, 0xde, 0xe4, 0xdf, 0xda, 0x0d, 0xd9, 0x89, 0xbe, 0x40, 0x92, 0x76, 0x0e, 0xf2, 0x56, 0x62,
	0xe2, 0xfd, 0xce, 0x9b, 0x27, 0x17, 0xda, 0x3d, 0x28, 0x76, 0xab, 0x79, 0x07, 0xb2, 0x19, 0x8a,
	0xf0, 0xab, 0x94, 0x4b, 0x8c, 0xe4, 0xa8, 0xad, 0x24, 0xaf, 0xa2, 0x27, 0x96, 0xc4, 0x28, 0xc0,
	0x98, 0x68, 0xb9, 0x40, 0x10, 0x07, 0x6d, 0x03, 0x54, 0x2e, 0x79, 0x4c, 0xdb, 0x76, 0x8b, 0x84,
	0x6c, 0x8b, 0x86, 0x89, 0x5a, 0x42, 0x74, 0xa5, 0x43, 0xbd, 0xe9, 0xde, 0x21, 0x28, 0x0d, 0x14,
	0xcb, 0xac, 0x2f, 0x61, 0x62, 0x47, 0x5a, 0xe5, 0x5b, 0x9b, 0xd1, 0xc5, 0x5c, 0xeb, 0xf1, 0x5c,
	0xa7, 0xff, 0xa2, 0x4d, 0xea, 0xf8, 0xd5, 0xad, 0xf8, 0x8d, 0x7f, 0x3f, 0x2c, 0xe1, 0x44, 0xb2,
	0x48, 0x3d, 0x27, 0x22, 0x5e, 0x10, 0x75, 0xde, 0x7f, 0x29, 0x95, 0x9b, 0x4e, 0xd4, 0x6a, 0xd7,
	0x75, 0x9b, 0x7a, 0x86, 0x5c, 0x0d, 0xe2, 0xcf, 0x12, 0x6b, 0xbc, 0x30, 0xa2, 0x4e, 0x40, 0x18,
	0x0f, 0xc3, 0xcc, 0x34, 0x65, 0xe5, 0x60, 0x02, 0xc6, 0x38, 0x22, 0x7e, 0x8b, 0x60, 0x5c, 0x8c,
	0x12, 0xd6, 0xb3, 0xde, 0x4a, 0xff, 0x14, 0x2b, 0xc6, 0xb9, 0xfd, 0x45, 0xd1, 0xda, 0xc2, 0xab,
	0x83, 0x6f, 0x6f, 0x46, 0xfe, 0xc6, 0x9a, 0x31, 0x74, 0x2d, 0xe1, 0x5d, 0x04, 0xd3, 0x3d, 0x83,
	0x8a, 0x57, 0x87, 0xa6, 0x3b, 0x6b, 0xea, 0x95, 0xb5, 0x8b, 0xca, 0x24, 0x6c, 0x85, 0xc3, 0x2e,
	0xe2, 0x85, 0x2c, 0x58, 0xcb, 0x75, 0x6b, 0x27, 0xc3, 0x8f, 0x3f, 0x22, 0xf8, 0xfd, 0xf4, 0x74,
	0xe2, 0xf5, 0xa1, 0x00, 0x03, 0x76, 0x85, 0x72, 0xed, 0x12, 0x4a, 0x49, 0xbf, 0xc6, 0xe9, 0x97,
	0xb1, 0x9e, 0x45, 0x9f, 0x92, 0xd7, 0xea, 0x9d, 0x9a, 0x18, 0xa2, 0x5d, 0x04, 0x53, 0xdd, 0x63,
	0x82, 0xaf, 0x0c, 0x6f, 0x5f, 0xff, 0x84, 0x2a, 0xab, 0x17, 0x54, 0x49, 0xea, 0x55, 0x4e, 0x6d,
	0xe0, 0xa5, 0xcc, 0x9e, 0x27, 0x3b, 0x22, 0xa6, 0x8e, 0xa7, 0x15, 0x7f, 0x40, 0xf0, 0xdb, 0xa9,
	0x2d, 0x83, 0xaf, 0x9e, 0x97, 0xe0, 0xd4, 0x82, 0x53, 0xd6, 0x2f, 0x2e, 0xfc, 0x39, 0xfa, 0x4f,
	0x08, 0x70, 0xff, 0xa6, 0xc0, 0x1b, 0x43, 0x39, 0x06, 0xee, 0x26, 0xe5, 0xfa, 0xa5, 0xb4, 0xb2,
	0x8c, 0x75, 0x5e, 0x46, 0x05, 0x2f, 0x67, 0x95, 0x91, 0x6c, 0x92, 0xda, 0x73, 0x1a, 0xd6, 0x64,
	0x4d, 0xd5, 0xfb, 0x7b, 0x47, 0x2a, 0xda, 0x3f, 0x52, 0xd1, 0xd7, 0x23, 0x15, 0xbd, 0x3e, 0x56,
	0x73, 0xfb, 0xc7, 0x6a, 0xee, 0xf3, 0xb1, 0x9a, 0x7b, 0x56, 0x11, 0xa1, 0x96, 0x6c, 0x1a, 0x12,
	0x23, 0xf9, 0x6e, 0x59, 0x8e, 0x6f, 0x78, 0xb4, 0xd1, 0x76, 0x49, 0x6f, 0x12, 0xbe, 0xb3, 0xea,
	0xe3, 0xfc, 0x17, 0xc4, 0xff, 0x3f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x40, 0x6b, 0x87, 0x70, 0x88,
	0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Params defines a gRPC query method that returns the permissions module's
	// parameters.
	Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	// AllNamespaces defines a gRPC query method that returns the permissions
	// module's created namespaces.
	AllNamespaces(ctx context.Context, in *QueryAllNamespacesRequest, opts ...grpc.CallOption) (*QueryAllNamespacesResponse, error)
	// NamespaceByDenom defines a gRPC query method that returns the permissions
	// module's namespace associated with the provided denom.
	NamespaceByDenom(ctx context.Context, in *QueryNamespaceByDenomRequest, opts ...grpc.CallOption) (*QueryNamespaceByDenomResponse, error)
	// AddressRoles defines a gRPC query method that returns address roles in the
	// namespace
	AddressRoles(ctx context.Context, in *QueryAddressRolesRequest, opts ...grpc.CallOption) (*QueryAddressRolesResponse, error)
	// AddressesByRole defines a gRPC query method that returns a namespace's
	// roles associated with the provided address.
	AddressesByRole(ctx context.Context, in *QueryAddressesByRoleRequest, opts ...grpc.CallOption) (*QueryAddressesByRoleResponse, error)
	// VouchersForAddress defines a gRPC query method that returns a map of
	// vouchers that are held by permissions module for this address, keyed by the
	// originator address
	VouchersForAddress(ctx context.Context, in *QueryVouchersForAddressRequest, opts ...grpc.CallOption) (*QueryVouchersForAddressResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, "/helios.permissions.v1beta1.Query/Params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AllNamespaces(ctx context.Context, in *QueryAllNamespacesRequest, opts ...grpc.CallOption) (*QueryAllNamespacesResponse, error) {
	out := new(QueryAllNamespacesResponse)
	err := c.cc.Invoke(ctx, "/helios.permissions.v1beta1.Query/AllNamespaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) NamespaceByDenom(ctx context.Context, in *QueryNamespaceByDenomRequest, opts ...grpc.CallOption) (*QueryNamespaceByDenomResponse, error) {
	out := new(QueryNamespaceByDenomResponse)
	err := c.cc.Invoke(ctx, "/helios.permissions.v1beta1.Query/NamespaceByDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AddressRoles(ctx context.Context, in *QueryAddressRolesRequest, opts ...grpc.CallOption) (*QueryAddressRolesResponse, error) {
	out := new(QueryAddressRolesResponse)
	err := c.cc.Invoke(ctx, "/helios.permissions.v1beta1.Query/AddressRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AddressesByRole(ctx context.Context, in *QueryAddressesByRoleRequest, opts ...grpc.CallOption) (*QueryAddressesByRoleResponse, error) {
	out := new(QueryAddressesByRoleResponse)
	err := c.cc.Invoke(ctx, "/helios.permissions.v1beta1.Query/AddressesByRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) VouchersForAddress(ctx context.Context, in *QueryVouchersForAddressRequest, opts ...grpc.CallOption) (*QueryVouchersForAddressResponse, error) {
	out := new(QueryVouchersForAddressResponse)
	err := c.cc.Invoke(ctx, "/helios.permissions.v1beta1.Query/VouchersForAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Params defines a gRPC query method that returns the permissions module's
	// parameters.
	Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
	// AllNamespaces defines a gRPC query method that returns the permissions
	// module's created namespaces.
	AllNamespaces(context.Context, *QueryAllNamespacesRequest) (*QueryAllNamespacesResponse, error)
	// NamespaceByDenom defines a gRPC query method that returns the permissions
	// module's namespace associated with the provided denom.
	NamespaceByDenom(context.Context, *QueryNamespaceByDenomRequest) (*QueryNamespaceByDenomResponse, error)
	// AddressRoles defines a gRPC query method that returns address roles in the
	// namespace
	AddressRoles(context.Context, *QueryAddressRolesRequest) (*QueryAddressRolesResponse, error)
	// AddressesByRole defines a gRPC query method that returns a namespace's
	// roles associated with the provided address.
	AddressesByRole(context.Context, *QueryAddressesByRoleRequest) (*QueryAddressesByRoleResponse, error)
	// VouchersForAddress defines a gRPC query method that returns a map of
	// vouchers that are held by permissions module for this address, keyed by the
	// originator address
	VouchersForAddress(context.Context, *QueryVouchersForAddressRequest) (*QueryVouchersForAddressResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (*UnimplementedQueryServer) AllNamespaces(ctx context.Context, req *QueryAllNamespacesRequest) (*QueryAllNamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllNamespaces not implemented")
}
func (*UnimplementedQueryServer) NamespaceByDenom(ctx context.Context, req *QueryNamespaceByDenomRequest) (*QueryNamespaceByDenomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NamespaceByDenom not implemented")
}
func (*UnimplementedQueryServer) AddressRoles(ctx context.Context, req *QueryAddressRolesRequest) (*QueryAddressRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddressRoles not implemented")
}
func (*UnimplementedQueryServer) AddressesByRole(ctx context.Context, req *QueryAddressesByRoleRequest) (*QueryAddressesByRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddressesByRole not implemented")
}
func (*UnimplementedQueryServer) VouchersForAddress(ctx context.Context, req *QueryVouchersForAddressRequest) (*QueryVouchersForAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VouchersForAddress not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helios.permissions.v1beta1.Query/Params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AllNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AllNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helios.permissions.v1beta1.Query/AllNamespaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AllNamespaces(ctx, req.(*QueryAllNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_NamespaceByDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNamespaceByDenomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).NamespaceByDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helios.permissions.v1beta1.Query/NamespaceByDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).NamespaceByDenom(ctx, req.(*QueryNamespaceByDenomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AddressRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAddressRolesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AddressRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helios.permissions.v1beta1.Query/AddressRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AddressRoles(ctx, req.(*QueryAddressRolesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AddressesByRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAddressesByRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AddressesByRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helios.permissions.v1beta1.Query/AddressesByRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AddressesByRole(ctx, req.(*QueryAddressesByRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_VouchersForAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryVouchersForAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).VouchersForAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/helios.permissions.v1beta1.Query/VouchersForAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).VouchersForAddress(ctx, req.(*QueryVouchersForAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "helios.permissions.v1beta1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "AllNamespaces",
			Handler:    _Query_AllNamespaces_Handler,
		},
		{
			MethodName: "NamespaceByDenom",
			Handler:    _Query_NamespaceByDenom_Handler,
		},
		{
			MethodName: "AddressRoles",
			Handler:    _Query_AddressRoles_Handler,
		},
		{
			MethodName: "AddressesByRole",
			Handler:    _Query_AddressesByRole_Handler,
		},
		{
			MethodName: "VouchersForAddress",
			Handler:    _Query_VouchersForAddress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "helios/permissions/v1beta1/query.proto",
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryAllNamespacesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAllNamespacesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAllNamespacesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryAllNamespacesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAllNamespacesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAllNamespacesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for iNdEx := len(m.Namespaces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Namespaces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryNamespaceByDenomRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryNamespaceByDenomRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryNamespaceByDenomRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncludeRoles {
		i--
		if m.IncludeRoles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryNamespaceByDenomResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryNamespaceByDenomResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryNamespaceByDenomResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Namespace != nil {
		{
			size, err := m.Namespace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAddressesByRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAddressesByRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAddressesByRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAddressesByRoleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAddressesByRoleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAddressesByRoleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAddressRolesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAddressRolesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAddressRolesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAddressRolesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAddressRolesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAddressRolesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryVouchersForAddressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVouchersForAddressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVouchersForAddressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryVouchersForAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVouchersForAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVouchersForAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vouchers) > 0 {
		for iNdEx := len(m.Vouchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vouchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryAllNamespacesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryAllNamespacesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Namespaces) > 0 {
		for _, e := range m.Namespaces {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryNamespaceByDenomRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.IncludeRoles {
		n += 2
	}
	return n
}

func (m *QueryNamespaceByDenomResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Namespace != nil {
		l = m.Namespace.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAddressesByRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAddressesByRoleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryAddressRolesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAddressRolesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryVouchersForAddressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryVouchersForAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vouchers) > 0 {
		for _, e := range m.Vouchers {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAllNamespacesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAllNamespacesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAllNamespacesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAllNamespacesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAllNamespacesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAllNamespacesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, &Namespace{})
			if err := m.Namespaces[len(m.Namespaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryNamespaceByDenomRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryNamespaceByDenomRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryNamespaceByDenomRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeRoles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeRoles = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryNamespaceByDenomResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryNamespaceByDenomResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryNamespaceByDenomResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Namespace == nil {
				m.Namespace = &Namespace{}
			}
			if err := m.Namespace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAddressesByRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAddressesByRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAddressesByRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAddressesByRoleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAddressesByRoleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAddressesByRoleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAddressRolesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAddressRolesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAddressRolesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAddressRolesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAddressRolesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAddressRolesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVouchersForAddressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVouchersForAddressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVouchersForAddressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVouchersForAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVouchersForAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVouchersForAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vouchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vouchers = append(m.Vouchers, types.Coin{})
			if err := m.Vouchers[len(m.Vouchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
